<!DOCTYPE html>
<html>
<head>
    <title>DISPLAY</title>
    <style>
        @font-face {
            font-family: 'Not-Angka';
            src: url('Parnumation 3.ttf') format('truetype');
        }

        body {
            margin: 0;
            height: 100vh;
            background-color: transparent;
            font-family: Arial, Helvetica, sans-serif;
            overflow: hidden; 
        }

        /* === CSS LOWER THIRD (Tidak berubah) === */
        #lower-third-bg {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            /* Tinggi akan diatur oleh JS */
            z-index: 0; /* Di belakang teks */
            overflow: hidden;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-in-out, height 0.3s ease-out; /* Transisi fade dan tinggi */
        }

        #lower-third-bg.visible {
            opacity: 0;
        }

        .lower-third-shape {
            position: absolute;
            bottom: 0;
            left: -10%; 
            width: 120%; 
            height: 100%; 
            /* Warna gradient bisa disesuaikan lagi jika perlu */
            background: linear-gradient(135deg, rgba(246, 62, 80, 0.8), rgba(249, 192, 192, 0.95));
            /* background: transparent; */
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.4);
            transform: skewX(-30deg);
            transition: transform 0.7s ease-out, opacity 0.5s ease-out; /* Transisi untuk animasi masuk/keluar */
            transform: translateX(-110%) skewX(-30deg); /* Mulai dari luar layar */
            opacity: 0; /* Mulai transparan */
        }

        #lower-third-bg.visible .lower-third-shape {
             transform: translateX(0) skewX(-30deg); /* Animasi masuk saat visible */
             opacity: 1;
        }
        /* === AKHIR CSS LOWER THIRD === */


        /* === CSS UNTUK ANIMASI KARAKTER (Tidak berubah) === */
        .char-animate {
            display: inline-block; /* Penting untuk transform dan layout spasi */
            opacity: 0;
            transform: translateX(-15px); /* Mulai sedikit dari kiri */
            animation: charReveal 0.4s cubic-bezier(0.215, 0.610, 0.355, 1.000) forwards; /* Animasi masuk */
            /* animation-delay akan diatur oleh JS */
        }

        @keyframes charReveal {
            from {
                opacity: 0;
                transform: translateX(-15px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        /* === AKHIR CSS ANIMASI KARAKTER === */

        /* Pastikan #display punya z-index dan posisi default */
        #display {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            max-width: 93%; /* Sesuaikan jika perlu, 90% lebih aman dari 95% */
            border-radius: 10px;
            white-space: pre-line; /* Penting untuk baris baru dan spasi */
            width: max-content; /* Lebar sesuai konten */
            max-height: 95vh;
            z-index: 1; /* Di atas lower third */
            /* Transisi untuk perubahan properti */
            /* transition: bottom 0.3s ease-out, background 0.5s ease, color 0.3s ease, text-shadow 0.3s ease, -webkit-text-stroke 0.3s ease; */
            transition: bottom 0.3s ease-out, /* background 0.5s ease, */ color 0.3s ease, text-shadow 0.3s ease, -webkit-text-stroke 0.3s ease; /* Nonaktifkan transisi background sementara */
            /* Default style jika localStorage kosong */
             color: #000000;
             bottom: 1%; /* Posisi default saat TIDAK ada lower third */
        }

        /* Style khusus saat lower third aktif (HANYA untuk hal yg tidak diatur JS) */
        #display.with-lower-third {
             /* Background akan diatur oleh JS (gradient/biru) */
             /* Color akan diatur oleh JS (dari localStorage) */
             /* Text-shadow akan diatur oleh JS (outline) */
             /* Bottom akan diatur oleh JS */
        }

        /* --- Style Konten (Tidak berubah) --- */
        .not-angka {
            font-family: 'Not-Angka', sans-serif;
        }
        .lyric {
            color: rgb(255, 255, 0); /* Tetap kuning untuk lirik */
        }
        .italic {
            font-style: italic;
        }
        .bold {
            font-weight: bold;
        }
        .icon, .verse-text, strong { /* Style Alkitab */
            /* ... (style alkitab tidak berubah) ... */
        }
        .icon { display: flex; position:fixed; top: -76px; left: 0%; z-index: 2; }
        .icon img { width: 110px; object-fit: contain; }
        .verse-text { width: 100%; padding-left: 2%; padding-top: 2px; margin-top: -4%; margin-bottom: -4%; max-width: 95%; text-align: justify; font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; }
        strong { color: rgb(226, 224, 224); display: flex; position: fixed; background-color: rgb(153, 57, 10); padding: 2px 10px 2px 130px; left: 0; top:-70px; z-index:1; }

        #church-logo-container { position: fixed; top: 10px; left: 10px; display: flex; align-items: center; z-index: 100; }
        #church-logo { width: 120px; height: 120px; margin-right: 10px; border-radius: 50%; box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); animation: shimmer 5s linear infinite; }
        /* #church-logo-text { font-size: 30px; font-weight: bold; color: #6755c9; text-shadow: 1px 1px 2px rgba(190, 186, 186, 0.5); position: relative; overflow: hidden; } */
        /* #church-logo-text::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, #fefefe, transparent); animation: goldShine 15s linear infinite; } */
        #church-logo-text {
            font-size: 30px;
            font-weight: bold;
            color: #6755c9; /* Warna dasar teks, akan diganti sebagian oleh gradient */
            text-shadow: 1px 1px 2px rgba(190, 186, 186, 0.5);
            position: relative;

            background: linear-gradient(90deg, #6755c9 25%, #ffffff 50%, #6755c9 75%); /* Gradient cahaya */
            background-size: 200% auto; /* Buat background lebih lebar untuk animasi */
            -webkit-background-clip: text; /* Klip background ke teks (prefix Webkit) */
            background-clip: text;         /* Klip background ke teks (standar) */
            color: transparent;            /* Buat warna teks asli transparan */
            animation: textShine 5s linear infinite; /* Terapkan animasi baru */
        }

        @keyframes textShine {
            0% {
                background-position: 200% center;
            }
            100% {
                background-position: -200% center;
            }
        }
        
        @keyframes shimmer { 0% { box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); } 50% { box-shadow: 0 0 20px rgba(255, 255, 255, 0.8); } 100% { box-shadow: 0 0 10px rgba(0, 0, 0, 0.5); } }
        /* @keyframes goldShine { 0% { left: -100%; } 50% { left: 100%; } 100% { left: 100%; } } */
        /* --- Akhir Style Logo Gereja --- */

        /* Kelas untuk menyembunyikan elemen */
        .hideable { }
        .hidden {
             display: none !important;
         }

         #content-wrapper {
            position: absolute; /* Atau fixed, agar bisa diatur left/width */
            top: 0;
            left: 0;
            width: 100%; /* Default: Lebar penuh */
            height: 100vh; /* Tinggi penuh */
            overflow: hidden; /* Sembunyikan konten yang keluar batas */
            transition: width 0.5s ease-in-out, left 0.5s ease-in-out, opacity 0.5s ease-in-out; /* Animasi perubahan layout */
            z-index: 0; /* Di bawah elemen lain jika perlu, tapi di atas background body */
        }

        /* Style untuk menyembunyikan wrapper saat layout 'camera' */
        #content-wrapper.hidden-layout {
            opacity: 0;
            pointer-events: none; /* Tidak bisa diklik */
            width: 0 !important; /* Paksa lebar 0 */
        }

        /* Penyesuaian style elemen anak agar relatif terhadap wrapper jika perlu */
        /* (Mungkin tidak perlu banyak perubahan jika elemen anak tetap 'fixed') */
        #display {
            /* position: fixed; (sudah) */
            /* left: 50%; transform: translateX(-50%); (akan diatur JS) */
            /* max-width: 90%; (tetap relatif viewport, OK) */
            /* ... */
        }

        #church-logo-container {
            /* position: fixed; (sudah) */
            /* top: 10px; right: 10px; (akan diatur JS relatif ke wrapper) */
            /* ... */
        }

        #lower-third-bg {
            /* position: fixed; (sudah) */
            /* bottom: 0; left: 0; width: 100%; (akan diatur JS) */
            /* ... */
        }

        /* Kelas untuk menyembunyikan elemen */
        .hideable { } /* Biarkan ini jika masih digunakan */
        .hidden {
            display: none !important; /* Kembali ke display: none */
        }

         /* Style untuk Webcam Video */
        #webcam-video {
            display: none; /* Sembunyikan secara default */
            position: fixed; /* Posisi relatif terhadap viewport */
            top: 0;
            left: 0; /* Default, akan diubah oleh JS */
            width: 100%; /* Default, akan diubah oleh JS */
            height: 100vh; /* Tinggi penuh viewport */
            object-fit: cover; /* Agar video mengisi area tanpa distorsi */
            background-color: #000; /* Background hitam jika video belum load/error */
            z-index: -1; /* Letakkan di belakang content-wrapper */
            transition: left 0.5s ease-in-out, width 0.5s ease-in-out; /* Animasi transisi */
        }

        /* ======================================== */
        /* ==        Webcam Feed Circle          == */
        /* ======================================== */

        .video-feed-circle {
            display: none; /* Awalnya tersembunyi, ditampilkan oleh JavaScript dengan menambahkan kelas .visible */
            position: fixed; /* Tetap posisinya relatif terhadap viewport */
            top:5%;    /* Jarak dari tepi bawah viewport */
            right: 5%;     /* Jarak dari tepi kanan viewport */
            width: 400px;    /* Diameter awal lingkaran */
            height: 400px;   /* Diameter awal lingkaran */
            border-radius: 50%; /* Membuat bentuk menjadi lingkaran */
            border: 4px solid gold; /* Border kuning emas */
            background-color: #111; /* Warna latar fallback jika video belum termuat */
            overflow: hidden; /* Memastikan konten (video) tetap di dalam batas lingkaran */
            z-index: 1050;    /* Pastikan di atas sebagian besar konten lain (misal, modal di 1000) */
            cursor: grab;     /* Kursor untuk menandakan elemen bisa digeser */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); /* Efek bayangan untuk memberi kedalaman visual */
            /* Anda bisa menambahkan transisi jika perubahan posisi/ukuran oleh JS ingin dianimasikan: */
            /* transition: width 0.2s ease, height 0.2s ease, bottom 0.2s ease, right 0.2s ease; */
        }

        .video-feed-circle.visible {
            display: block; /* Kelas ini ditambahkan oleh JS untuk menampilkan elemen */
        }

        .video-feed-circle video {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Mengisi lingkaran, video mungkin terpotong agar pas tanpa distorsi aspek rasio */
            display: block;    /* Menghilangkan spasi ekstra di bawah elemen video jika ada */
        }

        .video-feed-resize-handle {
            position: absolute;
            top: 1px; /* Posisi handle sedikit di dalam atau di atas border lingkaran */
            right: 1px;  /* Posisi handle sedikit di dalam atau di atas border lingkaran */
            width: 15px; /* Lebar area handle yang bisa diklik */
            height: 15px;/* Tinggi area handle yang bisa diklik */
            cursor: nwse-resize; /* Kursor untuk menandakan bisa diubah ukurannya secara diagonal */
            z-index: 1051; /* Di atas elemen video feed itu sendiri */
            box-sizing: border-box;
            opacity: 0.7; /* Opasitas default handle */
            /* Visual handle: dua border membentuk sudut, mirip dengan handle resize modal */
            /* Warna default adalah gold, bisa diubah atau di-theme jika perlu */
            border-right: 3px solid gold;
            border-bottom: 3px solid gold;
            transition: opacity 0.2s, border-color 0.2s; /* Transisi untuk hover effect */
        }

        .video-feed-circle:hover .video-feed-resize-handle {
            opacity: 1; /* Handle lebih jelas saat mouse hover di atas lingkaran video */
        }

        #text-flow-shaper {
            /* Styles for the shaper element, primarily set by JavaScript */
            /* It's floated right, and its dimensions + shape-outside make text wrap */
        }


    </style>
</head>
<body>
    <div id="content-wrapper">
        <!-- Church Logo -->
        <div id="church-logo-container" class="hideable">
            <img id="church-logo" src="image/icon/church-logo.png" alt="POUK Imanuel Logo">
            <span id="church-logo-text">POUK<br>IMANUEL</span>
        </div>

        <!-- Lower Third Background Container -->
        <div id="lower-third-bg" class="hideable">
            <div class="lower-third-shape"></div>
        </div>

        <!-- Display Area -->
        <div id="display" class="hideable"></div>
    </div> <!-- Akhir content-wrapper -->

    <!-- Elemen untuk menampilkan stream webcam (Latar Belakang Split/Full Camera) -->
    <video id="webcam-video" autoplay playsinline></video>

    <!-- Elemen untuk feed kamera berbentuk lingkaran (overlay) -->
    <div class="video-feed-circle" id="circularWebcamFeedContainer">
        <video id="circularWebcamVideo" autoplay playsinline></video> <!-- ID video unik -->
        <div class="video-feed-resize-handle" id="circularWebcamResizeHandle"></div>
    </div>

    <script>
        const display = document.getElementById('display');
        const lowerThirdBg = document.getElementById('lower-third-bg');
        const elementsToToggle = document.querySelectorAll('.hideable');
        const contentWrapper = document.getElementById('content-wrapper');
        const churchLogoContainer = document.getElementById('church-logo-container');
        // const webcamVideo = document.getElementById('webcam-video'); // <-- Tambahkan ini
        const mainWebcamVideo = document.getElementById('webcam-video'); // Untuk split/full background
        const circularWebcamFeedContainer = document.getElementById('circularWebcamFeedContainer');
        const circularWebcamVideo = document.getElementById('circularWebcamVideo'); // Video di dalam lingkaran

        let currentStyle = {};
        let isLowerThirdActive = false;
        let currentSource = 'unknown';
        let animationTimeoutId = null;
        let editorInitialLineCount = 0; // Store initial line count for editor

        // Kunci untuk localStorage
        const CIRCULAR_CAM_X_KEY = 'circularCamX';
        const CIRCULAR_CAM_Y_KEY = 'circularCamY';
        const CIRCULAR_CAM_SIZE_KEY = 'circularCamSize';


        // --- Fungsi Helper (Tidak berubah) ---
        function hexToRgb(hex) {
             if (!hex || !/^#[0-9A-F]{6}$/i.test(hex)) {
                return '255, 255, 255';
            }
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r}, ${g}, ${b}`;
        }


        // Fungsi baru untuk konversi hex ke array RGB [r, g, b]
        function hexToRgbArray(hex) {
            if (!hex || typeof hex !== 'string') return null;
            let sanitizedHex = hex.startsWith('#') ? hex.slice(1) : hex;
            if (sanitizedHex.length === 3) {
                sanitizedHex = sanitizedHex.split('').map(char => char + char).join('');
            }
            if (sanitizedHex.length !== 6) return null;
            const num = parseInt(sanitizedHex, 16);
            if (isNaN(num)) return null;
            return [(num >> 16) & 255, (num >> 8) & 255, num & 255];
        }

        // --- Fungsi Animasi Teks Masuk (Diperbaiki untuk Spasi dan Line Break v2) ---
        function animateTextIn() {
            if (animationTimeoutId) {
                clearTimeout(animationTimeoutId);
                animationTimeoutId = null;
            }

            // 1. Hapus elemen animasi lama (span dan <br> khusus)
            const oldAnimElements = display.querySelectorAll('span.char-animate, span.space-char, br.anim-br');
            oldAnimElements.forEach(el => {
                if (el.parentNode) {
                    if (el.tagName === 'SPAN') {
                        el.parentNode.replaceChild(document.createTextNode(el.textContent), el);
                    } else if (el.tagName === 'BR') {
                        el.parentNode.removeChild(el);
                    }
                }
            });

            // 2. Normalisasi DOM
            display.normalize();

            // 3. Delay kecil sebelum memulai animasi baru
            animationTimeoutId = setTimeout(() => {
                const nodesToProcess = Array.from(display.childNodes);
                const fragment = document.createDocumentFragment();
                let charIndex = 0;
                const delayFactor = 0.03;

                function processNode(node) {
                    // ... (logika processNode yang sudah ada tetap sama) ...
                    if (node.nodeType === Node.TEXT_NODE) {
                        const text = node.textContent;
                        for (let i = 0; i < text.length; i++) {
                            const char = text[i];

                            if (char === '\n') {
                                const br = document.createElement('br');
                                br.className = 'anim-br';
                                fragment.appendChild(br);
                            } else if (char.trim() !== '') {
                                const span = document.createElement('span');
                                span.textContent = char;
                                span.className = 'char-animate';
                                span.style.display = 'inline-block';
                                span.style.animationDelay = `${charIndex * delayFactor}s`;
                                fragment.appendChild(span);
                                charIndex++;
                            } else {
                                const span = document.createElement('span');
                                span.textContent = char;
                                span.className = 'space-char';
                                span.style.display = 'inline';
                                span.style.opacity = '1';
                                span.style.animation = 'none';
                                fragment.appendChild(span);
                            }
                        }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        const clonedNode = node.cloneNode(false);
                        processChildNodes(node, clonedNode);
                        fragment.appendChild(clonedNode);
                    } else {
                        fragment.appendChild(node.cloneNode(true));
                    }
                }

                function processChildNodes(originalParent, clonedParent) {
                    // ... (logika processChildNodes yang sudah ada tetap sama) ...
                    originalParent.childNodes.forEach(child => {
                        if (child.nodeType === Node.TEXT_NODE) {
                            const text = child.textContent;
                            for (let i = 0; i < text.length; i++) {
                                const char = text[i];
                                if (char === '\n') {
                                    const br = document.createElement('br');
                                    br.className = 'anim-br';
                                    clonedParent.appendChild(br);
                                } else if (char.trim() !== '') {
                                    const span = document.createElement('span');
                                    span.textContent = char;
                                    span.className = 'char-animate';
                                    span.style.display = 'inline-block';
                                    span.style.animationDelay = `${charIndex * delayFactor}s`;
                                    clonedParent.appendChild(span);
                                    charIndex++;
                                } else {
                                    const span = document.createElement('span');
                                    span.textContent = char;
                                    span.className = 'space-char';
                                    span.style.display = 'inline';
                                    span.style.opacity = '1';
                                    span.style.animation = 'none';
                                    clonedParent.appendChild(span);
                                }
                            }
                        } else if (child.nodeType === Node.ELEMENT_NODE) {
                            const clonedChild = child.cloneNode(false);
                            processChildNodes(child, clonedChild); // Rekursif lagi
                            clonedParent.appendChild(clonedChild);
                        } else {
                            clonedParent.appendChild(child.cloneNode(true));
                        }
                    });
                }

                nodesToProcess.forEach(processNode);

                // 4. Ganti konten display dengan fragment yang sudah diproses
                display.innerHTML = '';
                display.appendChild(fragment);

                // 5. Panggil applyStyle SETELAH DOM animasi selesai dibuat
                // Ini penting agar perhitungan background gradient/solid benar
                applyStyle(currentStyle); // Panggil applyStyle di sini

            }, 50); // Delay 50ms
        }

        // --- Fungsi Mengatur Tinggi Lower Third dan Posisi Display (Tidak berubah) ---
        function adjustLowerThirdLayout() {
            requestAnimationFrame(() => {
                if (!isLowerThirdActive || display.classList.contains('hidden')) {
                    lowerThirdBg.style.height = '0px';
                    display.style.bottom = '1%'; // Kembali ke default CSS
                    return;
                }
                const displayHeight = display.offsetHeight;
                const verticalPadding = 30;
                const minLowerThirdHeight = 80;
                const displayBottomMargin = 15;
                const targetLowerThirdHeight = Math.max(minLowerThirdHeight, displayHeight + verticalPadding);
                lowerThirdBg.style.height = `${targetLowerThirdHeight}px`;
                display.style.bottom = `${displayBottomMargin}px`;
            });
        }

        // --- Fungsi Menentukan Status Lower Third (Tidak berubah signifikan) ---
        function determineLowerThirdState(source, htmlContent) {
            let shouldBeActive = false;
            if (source === 'editor') {
                shouldBeActive = true;
            } else if (source === 'bible' || source === 'displayTab') {
                shouldBeActive = false;
            } else {
                const isBibleVerse = htmlContent.includes('<div class="icon">') || htmlContent.includes('<div class="verse-text">');
                shouldBeActive = !isBibleVerse;
            }

            const stateChanged = isLowerThirdActive !== shouldBeActive;
            isLowerThirdActive = shouldBeActive; // Update state global

            lowerThirdBg.classList.toggle('visible', isLowerThirdActive);
            // Class 'with-lower-third' akan di-toggle di applyStyle

            if (!isLowerThirdActive) {
                 // ... (reset style dinamis) ...
                 // Hapus sisa animasi
                 const oldAnimElements = display.querySelectorAll('span.char-animate, span.space-char, br.anim-br');
                 oldAnimElements.forEach(el => {
                     if(el.parentNode) {
                         if (el.tagName === 'SPAN') {
                            el.parentNode.replaceChild(document.createTextNode(el.textContent), el);
                         } else if (el.tagName === 'BR') {
                             el.parentNode.removeChild(el);
                         }
                     }
                 });
                 display.normalize();
                }

                // Panggil applyStyle untuk menerapkan gaya visual sesuai state baru
                // Jika lower third aktif, applyStyle akan dipanggil lagi di akhir animateTextIn
                // Jika tidak aktif, ini adalah pemanggilan utama untuk applyStyle
                applyStyle(currentStyle);

                return stateChanged; // Kembalikan status perubahan

        }

                // Fungsi baru untuk menerapkan style background pada textContainer (display)
        function applyDisplayBackground(textContainer, source, style, lineCount) {
            console.log(`[applyDisplayBackground] Source: ${source}, LineCount: ${lineCount}, Style BG: ${style.bgColor}, Style Opacity: ${style.opacity}`);
            // 'style' object di sini berisi style.bgColor dari lastDisplayStyle
            if (source === 'editor') { // Efek khusus hanya untuk preview editor
                const editorBgColorHex = style.bgColor || '#F0F0F0'; // Gunakan bgColor dari style, default abu-abu muda
                console.log(`[applyDisplayBackground] EDITOR mode. Color: ${editorBgColorHex}, Lines: ${lineCount}`);
                const rgbArray = hexToRgbArray(editorBgColorHex);

                if (rgbArray) {
                    textContainer.style.backgroundColor = ''; // Hapus backgroundColor solid jika ada
                    if (lineCount > 0 && lineCount % 2 !== 0) { // Ganjil
                        console.log("[applyDisplayBackground] EDITOR mode, ODD lines, applying right-transparent gradient.");
                        textContainer.style.background = `linear-gradient(to right, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},1) 0%, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},0) 100%)`;
                    } else if (lineCount > 0) { // Genap (dan bukan 0)
                        console.log("[applyDisplayBackground] EDITOR mode, EVEN lines, applying top/bottom opacity gradient.");
                        // Bagian atas opacity 0.7, bagian bawah opacity 1.0
                        const topBottomOpacityGradient = `linear-gradient(to bottom, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},0.7) 0%, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},0.7) 50%, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},1) 50.1%, rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},1) 100%)`;
                        const leftToRightFadeOut = `linear-gradient(to left, rgba(255,255,255,1) 0%, rgba(255,255,255,1) 20%, rgba(255,255,255,0) 100%)`;
                        const gradientCss = `${leftToRightFadeOut}, ${topBottomOpacityGradient}`;
                        textContainer.style.webkitMaskImage = ''; // Reset mask image
                        textContainer.style.maskImage = ''; // Reset mask image
                        
                        // Buat mask image: dari kiri opak (putih) ke kanan transparan (hitam)
                        // Area putih pada mask akan membuat konten terlihat, area hitam akan membuat konten transparan.
                        const maskGradient = `linear-gradient(to right, black 20%, black 100%)`;
                        textContainer.style.webkitMaskImage = maskGradient;
                        textContainer.style.maskImage = maskGradient;
                        textContainer.style.background = gradientCss;
                        console.log("[applyDisplayBackground] EDITOR EVEN CSS (background):", topBottomOpacityGradient);
                        console.log("[applyDisplayBackground] EDITOR EVEN CSS (mask):", maskGradient);
                    } else { // Tidak ada baris
                        console.log("[applyDisplayBackground] EDITOR mode, 0 lines, applying solid color.");
                        textContainer.style.webkitMaskImage = ''; // Reset mask image
                        textContainer.style.maskImage = ''; // Reset mask image
                        textContainer.style.background = `rgba(${rgbArray[0]},${rgbArray[1]},${rgbArray[2]},1)`; // Warna solid jika tidak ada baris
                    }
                } else {
                    console.warn("[applyDisplayBackground] EDITOR mode, invalid RGB array from hex. Applying transparent.");
                    textContainer.style.background = 'transparent'; // Fallback jika warna tidak valid
                }
            } else { // Untuk source 'bible', 'song', dll. (bukan 'editor')
                const bgRGBString = style.bgColor ? hexToRgb(style.bgColor) : '255, 255, 255';
                const bgOpacity = style.opacity || 1; // Gunakan opacity dari style utama
                textContainer.style.webkitMaskImage = ''; // Pastikan mask dihapus untuk mode non-editor
                textContainer.style.maskImage = ''; // Pastikan mask dihapus untuk mode non-editor
                console.log(`[applyDisplayBackground] NON-EDITOR mode. Applying solid: rgba(${bgRGBString}, ${bgOpacity})`);
                textContainer.style.background = ''; // Hapus gradient jika ada dari mode preview sebelumnya
                textContainer.style.backgroundColor = `rgba(${bgRGBString}, ${bgOpacity})`;
            }
        }


        // --- Fungsi Apply Content (Tidak berubah signifikan) ---
        function applyContent(rawText, source) {
            currentSource = source || 'unknown'; // Simpan sumber terakhir

            if (source === 'editor') {
                const editorParagraphs = (rawText || '').split(/\r\n\r\n|\n\n|\r\n|\n/);
                editorInitialLineCount = editorParagraphs.filter(p => p.trim() !== '').length;
                console.log(`[applyContent] Set editorInitialLineCount: ${editorInitialLineCount} for rawText: "${(rawText || '').substring(0,50)}"`);
            }

            if (rawText === null) rawText = '';
            const textToFormat = String(rawText); // Ini adalah teks mentah dari localStorage

            // Cek apakah ini konten Alkitab (untuk mencegah format ulang)
            // Anda mungkin perlu membuat deteksi ini lebih kuat jika format Alkitab bisa bervariasi
            const isBibleVerse = textToFormat.includes('<div class="icon">') || textToFormat.includes('<div class="verse-text">') || source === 'bible'; // Tambahkan cek source === 'bible' untuk keamanan
                let formattedHtml = textToFormat; // Mulai dengan teks mentah
                // Hanya format jika BUKAN ayat Alkitab
                // Pengecekan sumber dihapus agar teks dari displayTab juga diformat
                if (!isBibleVerse) {
                    // Proses formatting (replace %, *, _, #) sekarang berjalan untuk editor DAN displayTab
                    let txtHtml=escapeHtml(textToFormat);
                    // alert(escapeHtml(txtHtml));
                    formattedHtml = txtHtml.replace(/\%(.*?)\%/g, '<span class="not-angka">$1</span>')
                    .replace(/\*([\s\S]*?)\*/g, '<span class="bold">$1</span>')
                    .replace(/\_([\s\S]*?)\_/g, '<span class="italic">$1</span>')
                    .replace(/\#([\s\S]*?)\#/gm, '<span class="lyric">$1</span>');

                    // Ini untuk menghapus tag <ayatN>, <chorus> dll di sini jika TIDAK ingin menampilkannya di browser.html
                //  formattedHtml = formattedHtml.replace(/<\/?(ayat\d*|center|chorus|reff|bridge|intro|outro|verse\d*|v\d*)[^>]*>/gi, ''); // Opsional: Hapus tag custom
                }

            display.innerHTML = formattedHtml; // Menampilkan hasil yang sudah diformat (atau teks Alkitab asli)

            // Tentukan state lower third SEBELUM memanggil animasi/style
            const stateChanged = determineLowerThirdState(currentSource, formattedHtml);

            // Panggil animasi HANYA jika lower third aktif
            if (isLowerThirdActive) {
                animateTextIn(); // Panggil fungsi animasi di sini (applyStyle akan dipanggil di akhir animasi)
            } else {
                // Jika lower third TIDAK aktif, panggil applyStyle langsung
                applyStyle(currentStyle);
            }

            // adjustLowerThirdLayout akan dipanggil oleh applyStyle atau di akhir animasi
        }

        // Fungsi escapeHtml untuk atribut HTML (jika diperlukan terpisah)
        function escapeHtml(str) {
            if (typeof str !== 'string') return '';
            return str.replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>')
                    .replace(/&quot;/g, '"')
                    //   .replace(/&/g, '&amp;')
                    .replace(/&#039;/g, "'");
        }

        function applyStyle(style) {
            currentStyle = style || {};

            // Ambil SEMUA style dari localStorage atau default
            const fontSize = currentStyle.fontSize || '80';
            const fontColor = currentStyle.fontColor || '#000000'; // Ambil warna font dari setting
            const bgColor = currentStyle.bgColor || '#ffffff';
            const opacity = currentStyle.opacity || '0.5';
            const outlineWidth = parseFloat(currentStyle.outlineWidth || '0');
            const outlineColor = currentStyle.outlineColor || '#000000';

            // Terapkan style dasar yang selalu berlaku
            display.style.fontSize = `${fontSize}px`;
            display.style.color = fontColor; // SELALU gunakan warna font dari setting

            // Hapus style lama yang mungkin konflik
            display.style.background = '';
            display.style.backgroundColor = '';
            display.style.textShadow = ''; // Akan diatur oleh outline logic
            display.style.webkitTextStrokeWidth = '';
            display.style.webkitTextStrokeColor = '';
            display.style.paintOrder = '';
            display.style.bottom = ''; // Reset bottom, akan diatur jika perlu

            // Hitung jumlah baris yang sebenarnya ditampilkan untuk logika background
            // Pastikan display.textContent sudah terisi dengan benar sebelum pemanggilan ini
            const paragraphsArray = (display.textContent || '').split(/\r\n\r\n|\n\n|\r\n|\n/);
            // const nonEmptyParagraphsCount = paragraphsArray.filter(p => p.trim() !== '').length;
            // // console.log(`[applyStyle] Source: ${currentSource}, Lines for BG: ${nonEmptyParagraphsCount}, BGColor: ${currentStyle.bgColor}`);
            let nonEmptyParagraphsCount = paragraphsArray.filter(p => p.trim() !== '').length;
            console.log(`[applyStyle] Source: ${currentSource}, Lines for BG: ${nonEmptyParagraphsCount}, BGColor: ${currentStyle.bgColor}`);
            
            // For editor mode, especially when lower third (and thus animation) is active,
            // trust the initial line count calculated before animation.
            if (currentSource === 'editor' && isLowerThirdActive) {
                nonEmptyParagraphsCount = editorInitialLineCount;
                console.log(`[applyStyle] EDITOR mode with LowerThird, using editorInitialLineCount: ${nonEmptyParagraphsCount}`);
            }

            // Logika berdasarkan status lower third
            if (isLowerThirdActive) {
                display.classList.add('with-lower-third'); // Tambah class

                applyDisplayBackground(display, currentSource, currentStyle, nonEmptyParagraphsCount);

            } else {
                // Lower third TIDAK aktif
                display.classList.remove('with-lower-third'); // Hapus class
                applyDisplayBackground(display, currentSource, currentStyle, nonEmptyParagraphsCount);
                display.style.bottom = '1%'; // Gunakan posisi default
            }

            // --- Logika Outline (Berlaku untuk kedua kondisi) ---
            if (outlineWidth > 0) {
                display.style.webkitTextStrokeWidth = `${outlineWidth}px`;
                display.style.webkitTextStrokeColor = outlineColor; // Gunakan warna outline dari setting
                display.style.paintOrder = 'stroke fill';
                display.style.textShadow = 'none'; // Hapus shadow jika ada outline
                // console.log(`Applying outline: ${outlineWidth}px ${outlineColor}`);
            } else {
                // Hapus style outline jika tidak aktif
                display.style.webkitTextStrokeWidth = '';
                display.style.webkitTextStrokeColor = '';
                display.style.paintOrder = '';
                // console.log('Removing outline');
            }
            // --- Akhir Logika Outline ---

            // Panggil penyesuaian layout SETELAH semua style diterapkan
            // Delay kecil agar browser sempat render style sebelum mengukur
            setTimeout(adjustLowerThirdLayout, 0);
        }

        // --- Fungsi untuk Mengelola Text Flow Shaper ---
        function manageTextFlowShaper(enable) {
            let shaper = document.getElementById('text-flow-shaper');
            const displayArea = document.getElementById('display');

            if (enable) {
                if (!shaper && displayArea) {
                    shaper = document.createElement('div');
                    shaper.id = 'text-flow-shaper'; // Pastikan ID ini unik dan digunakan secara konsisten
                    if (displayArea.firstChild) {
                        displayArea.insertBefore(shaper, displayArea.firstChild);
                    } else {
                        displayArea.appendChild(shaper);
                    }
                }
                
                const webcamFeed = document.getElementById('circularWebcamFeedContainer');
                if (shaper && webcamFeed) {
                    // Gunakan ukuran aktual dari circularWebcamFeedContainer
                    const currentFeedWidth = parseFloat(webcamFeed.style.width) || webcamFeed.offsetWidth;
                    const currentFeedHeight = parseFloat(webcamFeed.style.height) || webcamFeed.offsetHeight;

                    const desiredGapFromText = 15;     // Desired space between text and the circle's edge

                    // Calculate the shaper's dimensions to match the webcam feed's OUTER dimensions
                    // Karena border-radius 50% pada webcamFeed, shaper harusnya sama ukurannya dengan webcamFeed
                    const shaperBoxWidth = currentFeedWidth;
                    const shaperBoxHeight = currentFeedHeight;

                    shaper.style.float = 'right';
                    shaper.style.width = `${shaperBoxWidth}px`;
                    shaper.style.height = `${shaperBoxHeight}px`;
                    
                    // shape-outside: circle(50%) will create a circle whose diameter
                    // matches the smaller of the shaperBoxWidth or shaperBoxHeight,
                    // centered within the shaperBox. Since width and height are equal here, it's a perfect fit.
                    shaper.style.shapeOutside = `circle(50%)`; 
                    
                    // shape-margin pushes the text away from the defined shape.
                    shaper.style.shapeMargin = `${desiredGapFromText}px`;
                    
                    // shaper.style.backgroundColor = 'rgba(255, 0, 0, 0.1)'; // Untuk debug
                    shaper.style.display = 'block'; // Ensure it's a block for float and dimensions
                }
            } else {
                if (shaper) {
                    shaper.style.display = 'none'; // Hide it when not in split-70 mode
                }
            }
        }

        // --- Revisi Fungsi applyLayout ---
        function applyLayout(layout) {
            console.log("Applying layout:", layout);
            const displayArea = document.getElementById('display');

            // Hapus class 'hidden-layout' dari wrapper SEBELUM mengatur style lain
            contentWrapper.classList.remove('hidden-layout'); // Pastikan selalu dihapus di awal
            mainWebcamVideo.style.display = 'none'; // Sembunyikan webcam background by default
            if (circularWebcamFeedContainer) {
                circularWebcamFeedContainer.classList.remove('visible'); // Sembunyikan bulatan kamera by default
            }
            // ... rest of resets ...
            if (document.getElementById('text-flow-shaper')) {
                manageTextFlowShaper(false); // Pastikan shaper dinonaktifkan untuk semua layout lain
            }


            // Reset style content wrapper ke default fullscreen
            contentWrapper.style.width = '100%';
            contentWrapper.style.left = '0';

            // Reset style #display ke default fullscreen
            if (displayArea) {
                displayArea.style.left = '50%';
                displayArea.style.width = ''; // Reset width to allow CSS 'max-content' to take effect by default
                displayArea.style.transform = 'translateX(-50%)';
                displayArea.style.maxWidth = '90%'; // Default max-width
                displayArea.style.paddingTop = '10px'; // Reset padding atas ke default CSS (dari "padding: 10px 20px;")
                displayArea.style.paddingRight = '20px'; // Reset padding kanan ke default CSS (dari "padding: 10px 20px;")
                displayArea.classList.remove('hidden');
            }

            // Reset lower third dan logo
            lowerThirdBg.style.width = '100%';
            lowerThirdBg.style.left = '0';
            churchLogoContainer.style.right = 'auto';
            churchLogoContainer.style.left = '10px';
            // Pastikan paddingRight displayArea direset ke nilai CSS defaultnya
            if (displayArea) {
                displayArea.style.paddingRight = '20px'; // Sesuai 'padding: 10px 20px;' di CSS
            }

            // Terapkan style spesifik layout
            switch (layout) {
                case 'split-50':
                    contentWrapper.style.width = '50%';
                    if (displayArea) {
                        displayArea.style.left = '25%';
                        displayArea.style.maxWidth = '45%';
                    }
                    lowerThirdBg.style.width = '50%';
                    mainWebcamVideo.style.display = 'block';
                    mainWebcamVideo.style.left = '50%';
                    mainWebcamVideo.style.width = '50%';
                    mainWebcamVideo.style.height = '100vh';

                    break;
                case 'split-70':
                    contentWrapper.style.width = '100%'; // Izinkan content wrapper (dan display di dalamnya) full width
                    contentWrapper.style.left = '0';
                    mainWebcamVideo.style.display = 'none'; // Sembunyikan video split 30% karena diganti bulatan

                    if (circularWebcamFeedContainer) {
                        // circularWebcamFeedContainer.classList.remove('visible'); // Remove this line if it exists
                        circularWebcamFeedContainer.classList.add('visible');
                    }
                    manageTextFlowShaper(true); // Aktifkan shaper untuk alur teks

                    if (displayArea) {
                        // Posisikan displayArea di tengah viewport
                        displayArea.style.left = '50%';
                        displayArea.style.transform = 'translateX(-50%)';
                        // // Atur maxWidth displayArea agar mengisi viewport, dikurangi padding kiri dan kanan default CSS.
                        // displayArea.style.maxWidth = 'calc(100% - 40px)'; // 40px = 20px kiri + 20px kanan dari CSS #display
                        // Explicitly set width for #display to enable text flow around shaper
                        displayArea.style.width = 'calc(100% - 40px)'; // 40px = 20px L + 20px R default padding
                        //padddingRight sudah direset ke 20px di atas, shaper akan menangani sisanya.
                    }

                    lowerThirdBg.style.width = '100%'; // Lower third juga full width
                    break;
                case 'camera':
                    // In 'camera' layout, the main webcam video is fullscreen background.
                    // The circular feed can still be an overlay on top of it.
                    mainWebcamVideo.style.display = 'block';
                    mainWebcamVideo.style.left = '0%';
                    mainWebcamVideo.style.width = '100%';
                    mainWebcamVideo.style.height = '100vh';
                    if (circularWebcamFeedContainer) {
                        circularWebcamFeedContainer.classList.add('visible'); // Show circular feed in camera layout
                    }
                    break;
                case 'fullscreen':
                default:
                break;
            }

            // Panggil adjustLowerThirdLayout setelah layout berubah
            // Ini penting agar lower third disembunyikan jika layout camera
            setTimeout(adjustLowerThirdLayout, 550); // Mungkin perlu delay lebih singkat?

            // Panggil setVisibility untuk menerapkan status toggle ON/OFF
            const currentHiddenState = localStorage.getItem('toggleContent') === 'true';
            setVisibility(currentHiddenState);

            // Also ensure circular cam visibility is handled by setVisibility based on master toggle
            // setVisibility is called right after applyLayout, so it should handle it.
            // However, setVisibility currently only hides elements *inside* content-wrapper.
            // We need setVisibility to also hide the circular cam if the master toggle is OFF.
        }

    // --- Revisi Fungsi setVisibility ---
    function setVisibility(isHidden) {
        const currentLayout = localStorage.getItem('settingLayout') || 'fullscreen';
        console.log(`setVisibility called. isHidden: ${isHidden}, currentLayout: ${currentLayout}`);

        // Jika BUKAN camera, pastikan wrapper TIDAK punya class hidden-layout (double check)
        // Jika layout ADALAH camera, applyLayout sudah memastikan wrapper TIDAK hidden
        if (currentLayout !== 'camera' && contentWrapper.classList.contains('hidden-layout')) {
           contentWrapper.classList.remove('hidden-layout');
           console.log("setVisibility removed hidden-layout (should have been done by applyLayout)");
        }

        // --- Logika untuk elemen INSIDE wrapper (berlaku untuk SEMUA layout sekarang) ---
        const logoContainer = document.getElementById('church-logo-container');
        const displayArea = document.getElementById('display');
        const lowerThird = document.getElementById('lower-third-bg');
        const circularCam = document.getElementById('circularWebcamFeedContainer'); // Get circular cam element

        // Ambil status toggle dari localStorage
        const showLogoSetting = localStorage.getItem('settingLogoEnabled') !== 'false';
        const showTextSetting = localStorage.getItem('settingTextEnabled') !== 'false';
        console.log(`showLogoSetting: ${showLogoSetting}, showTextSetting: ${showTextSetting}`);

        // Tentukan apakah masing-masing elemen harus hidden
        let isDisplayHidden = isHidden || !showTextSetting;
        let isLogoHidden = isHidden || !showLogoSetting;
        // Lower third visibility: hidden jika master toggle/text toggle off, ATAU jika layout camera, ATAU jika displayArea hidden
        let isLowerThirdHidden = isHidden || !showTextSetting || currentLayout === 'camera'; // <-- Tambahkan || currentLayout === 'camera'
        // Circular cam visibility: hidden jika master toggle off, ATAU jika layout BUKAN split-70 atau camera
        let isCircularCamHidden = isHidden || (currentLayout !== 'split-70' && currentLayout !== 'camera'); // <-- Add logic for circular cam

        console.log(`Calculated visibility: display=${!isDisplayHidden}, logo=${!isLogoHidden}, lowerThird=${!isLowerThirdHidden}, circularCam=${!isCircularCamHidden}`);

        // Terapkan class 'hidden' berdasarkan kalkulasi di atas
        if (logoContainer) {
            logoContainer.classList.toggle('hidden', isLogoHidden);
        }
        if (displayArea) {
            displayArea.classList.toggle('hidden', isDisplayHidden);
        }
        if (lowerThird) {
            // Pastikan juga class 'visible' pada lowerThirdBg dihapus jika harus hidden
            lowerThird.classList.toggle('hidden', isLowerThirdHidden);
            lowerThirdBg.classList.toggle('visible', !isLowerThirdHidden && isLowerThirdActive); // Update class visible juga
        }
        // Handle circular cam visibility based on toggle and layout
        if (circularCam) {
             circularCam.classList.toggle('hidden', isCircularCamHidden);
             circularCam.classList.toggle('visible', !isCircularCamHidden); // Ensure .visible class is also managed
        }

        // Tentukan apakah ada sesuatu yang *seharusnya* terlihat di wrapper
        const somethingShouldBeVisible = (!isDisplayHidden && displayArea) || (!isLogoHidden && logoContainer);

        if (somethingShouldBeVisible) {
            // Jika ada yg terlihat, pastikan style teks diterapkan (jika teks terlihat)
            if (!isDisplayHidden) {
                applyStyle(currentStyle); // applyStyle akan memanggil adjustLowerThirdLayout
            } else {
                 // Jika display hidden tapi logo visible, mungkin perlu panggil adjustLowerThird?
                 // Atau biarkan applyStyle yang mengurusnya? Untuk saat ini biarkan.
            }

            // Atur tinggi lower third hanya jika lower third itu sendiri TIDAK hidden
            // (Logika ini mungkin bisa disederhanakan karena applyStyle sudah memanggil adjustLowerThirdLayout)
            if (!isLowerThirdHidden && lowerThird && isLowerThirdActive) { // Tambah cek isLowerThirdActive
                console.log("Adjusting lower third layout.");
                setTimeout(adjustLowerThirdLayout, 50);
            } else {
                if (lowerThird) {
                    console.log("Collapsing lower third (not active or hidden or camera layout).");
                    lowerThird.style.height = '0px';
                }
            }
        } else {
            // Jika tidak ada yang terlihat, pastikan lower third collaps
            if (lowerThird) {
                console.log("Collapsing lower third (nothing visible in wrapper).");
                lowerThird.style.height = '0px';
            }
            console.log("No active/visible elements in wrapper.");
        }

        // If circular cam is visible and layout is split-70, ensure shaper is active
        if (currentLayout === 'split-70' && !isCircularCamHidden) {
             manageTextFlowShaper(true);
        } else {
             manageTextFlowShaper(false); // Ensure shaper is off otherwise
        }

    }

        // --- Fungsi untuk Memulai Webcam ---
        async function startWebcam() {
            // Cek dulu apakah browser mendukung getUserMedia
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error("getUserMedia() not supported.");
                alert("Browser Anda tidak mendukung akses webcam.");
                // Sembunyikan elemen video jika tidak didukung
                // const webcamVideo = document.getElementById('webcam-video');
                // if (webcamVideo) webcamVideo.style.display = 'none';
                if (mainWebcamVideo) mainWebcamVideo.style.display = 'none';
                if (circularWebcamFeedContainer) circularWebcamFeedContainer.classList.remove('visible');
                return;
            }

            try {
                // Minta akses ke video saja, tanpa audio
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });

                // Salurkan stream ke kedua elemen video jika ada
                // (atau Anda bisa memiliki logika untuk memilih salah satu berdasarkan state)
                if (mainWebcamVideo) {
                    mainWebcamVideo.srcObject = stream;
                }
                if (circularWebcamVideo) {
                    // Buat stream baru atau clone stream jika diperlukan agar tidak ada konflik
                    // Untuk contoh ini, kita akan coba gunakan stream yang sama.
                    // Perlu diuji apakah ini bekerja dengan baik di semua browser atau jika stream perlu di-clone. (It usually works fine)
                    // const clonedStream = stream.clone(); // Jika diperlukan
                    circularWebcamVideo.srcObject = stream; 
                }
                
                console.log("Webcam stream started successfully and applied to video elements.");

                // Contoh: Tampilkan webcam lingkaran jika layout adalah fullscreen dan webcam diizinkan
                // Visibility is now handled by applyLayout and setVisibility
                // No need to add .visible here.
                // if (circularWebcamFeedContainer) { circularWebcamFeedContainer.classList.add('visible'); } // REMOVE THIS LINE

            } catch (err) {
                console.error("Error accessing webcam:", err);
                // const webcamVideo = document.getElementById('webcam-video');

                // Beri tahu pengguna tentang error spesifik
                if (err.name === "NotAllowedError") { // Dulu 'PermissionDeniedError'
                    alert("Anda telah menolak izin akses webcam. Webcam tidak dapat ditampilkan.");
                } else if (err.name === "NotFoundError") { // Dulu 'DevicesNotFoundError'
                    alert("Tidak ada webcam yang ditemukan di perangkat Anda.");
                } else if (err.name === "NotReadableError") { // Dulu 'TrackStartError'
                    // alert("Webcam sedang digunakan oleh aplikasi lain atau ada masalah hardware.");
                    alert("Webcam mungkin sedang digunakan oleh aplikasi lain atau ada masalah hardware.");
                } else {
                    alert("Terjadi kesalahan saat mencoba mengakses webcam: " + err.message);
                }

                // Sembunyikan elemen video jika terjadi error
                if (mainWebcamVideo) mainWebcamVideo.style.display = 'none';
                if (circularWebcamFeedContainer) {
                    circularWebcamFeedContainer.classList.remove('visible');
                    circularWebcamFeedContainer.classList.add('hidden'); // Also hide it explicitly
                }
            }
        }
        
        // --- Modifikasi Listener localStorage ---
        window.addEventListener('storage', (event) => {
        console.log('Storage event detected:', event.key);

        if (event.key === 'lastDisplayedText' || event.key === 'lastDisplaySource') {
            const newText = localStorage.getItem('lastDisplayedText');
            const newSource = localStorage.getItem('lastDisplaySource');
            applyContent(newText, newSource); // applyContent akan memanggil applyStyle & adjustLowerThird
        } else if (event.key === 'lastDisplayStyle') {
            try {
                const newStyle = JSON.parse(event.newValue || '{}');
                // currentStyle akan diupdate di dalam applyStyle
                // Panggil applyStyle untuk menerapkan perubahan gaya.
                console.log("[Storage Event] lastDisplayStyle changed. Calling applyStyle.");
                applyStyle(newStyle); 
            } catch (e) { console.error("Gagal parse style dari storage event:", e); }
        } else if (event.key === 'toggleContent') {
             const isHidden = event.newValue === 'true';
             setVisibility(isHidden); // Cukup panggil setVisibility
        } else if (event.key === 'settingLogoEnabled' || event.key === 'settingTextEnabled') {
             // Panggil setVisibility lagi untuk mengevaluasi ulang visibilitas elemen konten
             setVisibility(localStorage.getItem('toggleContent') === 'true');
        } else if (event.key === CIRCULAR_CAM_X_KEY || event.key === CIRCULAR_CAM_Y_KEY || event.key === CIRCULAR_CAM_SIZE_KEY) {
             // If circular cam state changes in storage, reload it (e.g., if another browser window changes it)
             setVisibility(localStorage.getItem('toggleContent') === 'true');
        } else if (event.key === 'settingLayout') {
             applyLayout(event.newValue || 'fullscreen'); // applyLayout akan memanggil setVisibility di akhir
        }
    });

        // --- Modifikasi Inisialisasi Awal ---
        const initialText = localStorage.getItem('lastDisplayedText');
        const initialSource = localStorage.getItem('lastDisplaySource');
        const initialStyleJSON = localStorage.getItem('lastDisplayStyle');
        const initialVisibilityHidden = localStorage.getItem('toggleContent') === 'true';
        const initialLayout = localStorage.getItem('settingLayout') || 'fullscreen';

        let initialStyle = {};
         if (initialStyleJSON) {
            try { initialStyle = JSON.parse(initialStyleJSON); } catch (e) { console.error("Gagal parse initial style:", e); initialStyle = {}; }
        }
        currentStyle = initialStyle;

        // 0. Mulai webcam (akan meminta izin jika belum diberikan)
        startWebcam();

        // 1. Muat state circular cam dari localStorage
        if (circularWebcamFeedContainer) { loadCircularCamState(circularWebcamFeedContainer); }

        // 2. Terapkan layout awal DULU (ini akan mengatur posisi/visibilitas wrapper, main webcam, dan circular cam)
        applyLayout(initialLayout); // applyLayout memanggil setVisibility di akhir

        // 3. Terapkan konten awal (ini akan memanggil applyStyle dan adjustLayout untuk konten di dalam wrapper)
        applyContent(initialText || '<p>Konten akan tampil di sini...</p>', initialSource);

        const circularWebcamResizeHandle = document.getElementById('circularWebcamResizeHandle');

        function loadCircularCamState(element) {
            if (!element) return;
            const savedX = localStorage.getItem(CIRCULAR_CAM_X_KEY);
            const savedY = localStorage.getItem(CIRCULAR_CAM_Y_KEY);
            const savedSize = localStorage.getItem(CIRCULAR_CAM_SIZE_KEY);

            if (savedX && savedY) {
                element.style.left = savedX;
                element.style.top = savedY;
                element.style.right = 'auto'; // Pastikan ini direset jika left/top digunakan
                element.style.bottom = 'auto';
            }
            // Jika tidak ada posisi tersimpan, biarkan CSS default (top:5%, right:5%) yang berlaku.
            // Drag pertama akan mengkonversinya ke left/top.

            if (savedSize) {
                element.style.width = savedSize;
                element.style.height = savedSize; // Jaga agar tetap lingkaran
            }
            // Jika tidak ada ukuran tersimpan, biarkan CSS default (width/height: 400px) yang berlaku.
        }

        function saveCircularCamState(element) {
            if (!element) return;
            // Simpan hanya jika style left/top/width telah diatur oleh interaksi
            if (element.style.left && element.style.top) {
                localStorage.setItem(CIRCULAR_CAM_X_KEY, element.style.left);
                localStorage.setItem(CIRCULAR_CAM_Y_KEY, element.style.top);
            }
            if (element.style.width) { // Asumsi width dan height sama
                localStorage.setItem(CIRCULAR_CAM_SIZE_KEY, element.style.width);
            }
        }
        // --- Fungsi untuk membuat elemen draggable ---
        function makeDraggable(element) {
            let offsetX, offsetY, isDragging = false;

            element.addEventListener('mousedown', (e) => {
                // Hanya drag jika targetnya adalah elemen itu sendiri, bukan video atau handle resize di dalamnya
                if (e.target === element || e.target === circularWebcamVideo) {
                    isDragging = true;
                    // Hitung offset dari posisi mouse ke pojok kiri atas elemen
                    offsetX = e.clientX - element.getBoundingClientRect().left;
                    offsetY = e.clientY - element.getBoundingClientRect().top;
                    element.style.cursor = 'grabbing';
                    // Mencegah seleksi teks saat dragging
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // Hitung posisi baru elemen
                let newX = e.clientX - offsetX;
                let newY = e.clientY - offsetY;

                // Batasi agar elemen tidak keluar dari viewport
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const elementWidth = element.offsetWidth;
                const elementHeight = element.offsetHeight;

                newX = Math.max(0, Math.min(newX, viewportWidth - elementWidth));
                newY = Math.max(0, Math.min(newY, viewportHeight - elementHeight));

                element.style.left = `${newX}px`;
                element.style.top = `${newY}px`;
                // Karena kita mengubah left/top, pastikan bottom/right direset jika sebelumnya digunakan
                element.style.right = 'auto';
                element.style.bottom = 'auto';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    element.style.cursor = 'grab';
                    saveCircularCamState(element); // Simpan posisi setelah drag selesai
                }
            });
        }

        // --- Fungsi untuk membuat elemen resizable ---
        function makeResizable(element, resizeHandle) {
            let startX, startY, startWidth, startHeight, isResizing = false;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(element).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(element).height, 10);
                // Mencegah event mousedown pada handle memicu drag pada parent
                e.stopPropagation();
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                // Untuk lingkaran, kita ingin perubahan width dan height proporsional.
                // Kita bisa menggunakan delta yang lebih besar atau rata-rata,
                // atau hanya satu sumbu jika ingin resize hanya dari satu arah handle.
                // Karena handle di kanan bawah, kita bisa fokus pada deltaX dan deltaY.
                // Untuk menjaga bentuk lingkaran, width dan height harus sama.
                // Kita ambil perubahan terbesar atau salah satu (misal deltaX) dan terapkan ke keduanya.
                // Atau, kita bisa buat perubahan berdasarkan pergerakan diagonal.
                // Untuk simpelnya, kita buat width dan height bertambah/berkurang sama:
                
                let newWidth = startWidth + deltaX; // Bisa juga (startWidth + deltaX + startHeight + deltaY) / 2 untuk rata-rata
                let newHeight = startHeight + deltaY; // Atau sama dengan newWidth untuk lingkaran sempurna

                // Jaga agar width dan height sama untuk lingkaran, ambil salah satu atau rata-rata
                // Misalnya, kita ambil perubahan dari X dan terapkan ke Y juga, atau sebaliknya,
                // atau kita bisa membuat perubahan berdasarkan jarak mouse dari titik awal resize.
                // Untuk handle di kanan bawah, perubahan width dan height bisa independen
                // namun karena border-radius 50%, kita ingin width dan height tetap sama.
                // Mari kita buat perubahan berdasarkan deltaX, dan set height = width.
                
                const newSize = Math.max(50, startWidth + deltaX); // Ukuran minimum 50px

                element.style.width = `${newSize}px`;
                element.style.height = `${newSize}px`; // Jaga agar tetap lingkaran
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    saveCircularCamState(element); // Simpan ukuran setelah resize selesai

                    // Jika shaper aktif untuk layout saat ini, perbarui
                    const currentLayout = localStorage.getItem('settingLayout') || 'fullscreen';
                    if (currentLayout === 'split-70' && document.getElementById('text-flow-shaper')) {
                        manageTextFlowShaper(true);
                    }
                }
            });
        }

        startWebcam();
        applyLayout(initialLayout); // Ini akan memanggil manageTextFlowShaper jika layout split-70
        applyContent(initialText || '<p>Konten akan tampil di sini...</p>', initialSource);

        if (circularWebcamFeedContainer && circularWebcamResizeHandle) {
            makeDraggable(circularWebcamFeedContainer);
            // makeResizable(circularWebcamFeedContainer, circularWebcamResizeHandle);
        }

        if (circularWebcamResizeHandle) {
            // makeDraggable(circularWebcamFeedContainer);
            makeResizable(circularWebcamFeedContainer, circularWebcamResizeHandle);
        }
      
        console.log("Inisialisasi selesai.");
        
        </script>
</body>
</html>
